//declared zipInput, countryInput, and submitLocation vars to connect the search form in index.html to the script.js
var zipInput = document.querySelector("#zipcodeInput");
var countryInput = document.querySelector('#countryInput');
var submitLocation = document.querySelector('#submitLocation');
//declared city name, lat/lon, and cityArray globally since they are used in several functions and need to be accessible
//cityObj is used as the prototype for the searched city objects to be based on
var cityName = '';
var lat = 0;
var lon = 0;
var searchHistory = document.querySelector('#searchHistory')
var cityArray = [];
const cityObj = {
    cityName: '',
    lat: '',
    lon: ''
}

//getLocation function takes the zip and country input values (from user input) and uses the geocoding offered by the openweathermap api to get the city name and the coordinates of the searched location from the data generated
//once the response has been returned, the genNewCity, getWeather, and getForecast functions are called -- this ensures that the current weather and 5-day forecast api calls are not made unless the geocoding api call has been made successfully
function getLocation(event) {
    event.preventDefault();
    var zip = zipInput.value
    var country = countryInput.value
    console.log(zip)
    console.log(country)
    var geoQueryURL = 'https://api.openweathermap.org/geo/1.0/zip?zip=' + zip + ',' + country + '&appid=' + APIKey
    fetch(geoQueryURL)
        .then(function (response) {
            return response.json();
        })
        .then(function(data) {
            cityName = data.name
            lat = data.lat
            lon = data.lon
            genNewCity();
            getWeather();
            getForecast();
        })
        

}

//genNewCity function creates a new city button in the search history. The text content and city name attribute of the button are assigned the value of the cityName variable (which gets the city name from the geocoding in the getLocation function) -- the cityNameAtt is set to identify which object (stored city data) is associated with the clicked button so that one event listener can be used for the entire search history 
//genNewCity also creates a new object (using the cityObj as the prototype), pushes the new city object to the cityArray, and saves the array to local storage -- this allows the geocoding API call to be made just once for each city, since the relevant data from the initial search/fetch are saved locally 
function genNewCity() {
    var cityButton = document.createElement('button')
    cityButton.setAttribute('cityNameAtt', cityName)
    cityButton.textContent = cityName;
    searchHistory.appendChild(cityButton)

    var newCity = Object.create(cityObj);
    newCity.cityName = cityName;
    newCity.lat = lat;
    newCity.lon = lon;
    cityArray.push(newCity);
    localStorage.setItem('cityArray',JSON.stringify(cityArray))
    console.log(cityArray)
}

//the searchHistory event listener applies to all buttons generated in the search history - when a button is clicked, the event listener will get the city name attribute for the clicked button (event target), parse the cityArray data pulled from local storage, and cycle through the stored city array objects and check if the city name attribute of the clicked button matches the city name of each object in the stored city array. 
//if the names match, the cityName, lat, and lon variable values are reassigned to the values stored in the matching object and these values are used in the getWeather and getForecast function calls (the current weather and five day forecast are generated for the city whose button was clicked)
searchHistory.addEventListener('click', function(event) {
    var clickedButton = event.target;
    var cityNameAtt = clickedButton.getAttribute('cityNameAtt')
    var cityStore = JSON.parse(localStorage.getItem('cityArray'))
    for(i=0; i<cityStore.length; i++) {
        if (cityNameAtt == cityStore[i].cityName) {
            cityName = cityStore[i].cityName;
            lat = cityStore[i].lat;
            lon = cityStore[i].lon;
            console.log(cityStore[i])
            getWeather();
            getForecast();
        }
  
    }
})
//when submitLocation button is clicked, the getLocation function is run
submitLocation.addEventListener('click', getLocation)


//getWeather function makes the api call to openweathermap to get the data for the current weather in the searched city based on the latitude and longitude generated by the geocoding in getLocation
//When the response is returned, the data is used to set the text content for the current temperature, wind speed, and humidity
//the city name text content comes from the cityName generated in the geocoding in getlocation, and the current date is pulled from and formatted by dayjs
function getWeather() {
    var weatherQueryURL = 'https://api.openweathermap.org/data/2.5/weather?lat=' + lat +'&lon=' + lon + '&appid=' + APIKey + '&units=imperial';
    fetch(weatherQueryURL)
        .then(function (response) {
            return response.json();
        })
        .then(function (data) {
            var todayCity = document.querySelector('#todayCity');
            var todayTemp = document.querySelector('#todayTemp');
            var todayWind = document.querySelector('#todayWind');
            var todayHumidity = document.querySelector('#todayHumidity');
            var weatherIcon = document.querySelector('#wicon')
            var iconURL = "https://openweathermap.org/img/wn/" + data.weather[0].icon + ".png";
            console.log(data.weather[0].icon)
        

            todayCity.textContent = cityName + ' (' + dayjs().format('M/D/YYYY') + ')'
            weatherIcon.setAttribute("src", iconURL)
            todayTemp.textContent = data.main.temp + ' °F'
            todayWind.textContent = data.wind.speed + ' miles/hour'
            todayHumidity.textContent = data.main.humidity + '%'

})
}

//the getForecast function makes the api call to openweathermap to get the data for the 5 day forecast in the searched city based on the latitude and longitude generated by the geocoding in getLocation
//when the response is returned, the data is used to set the text content for the temperature, wind speed, and humidity for each day. Since the api call returns data for every three hours, the for loop is set up such that only the data from every 8th time stamp (every 24 hours) is used.
//the date for each day in the forecast is pulled from and formatted by dayjs
function getForecast() {
    var forecastQueryURL = 'https://api.openweathermap.org/data/2.5/forecast?lat=' + lat + '&lon=' + lon + '&appid=' + APIKey + '&units=imperial'
    fetch(forecastQueryURL)
        .then(function (response) {
            return response.json();
        })
        .then(function (data) {
            var date0 = document.querySelector('#day0Date');
            var date1 = document.querySelector('#day1Date');
            var date2 = document.querySelector('#day2Date');
            var date3 = document.querySelector('#day3Date');
            var date4 = document.querySelector('#day4Date');

            date0.textContent = dayjs().add(1, 'day').format('M/D/YYYY')
            date1.textContent = dayjs().add(2, 'day').format('M/D/YYYY')
            date2.textContent = dayjs().add(3, 'day').format('M/D/YYYY')
            date3.textContent = dayjs().add(4, 'day').format('M/D/YYYY')
            date4.textContent = dayjs().add(5, 'day').format('M/D/YYYY')
            
            
            for (i=1; i<6;i++) {
                document.querySelector('#day'+i+'Temp').textContent = data.list[(i*8) - 1].main.temp + ' °F'
                document.querySelector('#day'+i+'Wind').textContent = data.list[(i*8) - 1].wind.speed + ' miles/hour'
                document.querySelector('#day'+i+'Humidity').textContent = data.list[(i*8) - 1].main.humidity + '%'
                console.log(data.list[(i*8) - 1].dt_txt)
                document.querySelector('#wiconday'+i).setAttribute('src', "https://openweathermap.org/img/wn/" + data.list[(i*8) - 1].weather[0].icon + ".png" )
            }
            

        })
}

